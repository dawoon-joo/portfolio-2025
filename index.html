<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
	<link rel="stylesheet" href="/common/css/font/font.css">
	<link rel="stylesheet" href="/common/css/swiper.min.css">
	<link rel="stylesheet" href="/common/css/jquery.fullpage.min.css">
	<link rel="stylesheet" href="/common/css/base.css">
	<link rel="stylesheet" href="/common/css/sub.css">
	<link rel="stylesheet" href="/common/css/main.css">
	<link rel="stylesheet" href="/common/css/common.css">
	<script src="/common/js/gsap.min.js"></script>
	<script src="/common/js/ScrollTrigger.min.js"></script>
	<script src="/common/js/ScrollToPlugin.min.js"></script>
	<script src="/common/js/ScrollMagic.min.js"></script>
	<script src="/common/js/scrollreveal.min.js"></script>
	<script src="/common/js/lenis.min.js"></script>
	<script src="/common/js/swiper.min.js"></script>
	<script src="/common/js/jquery-3.7.1.min.js"></script>
	<script src="/common/js/matter.js"></script>
	<script src="/common/js/main.js"></script>
	<script src="/common/js/sub.js"></script>
	<script src="/common/js/device.js"></script>
	<script src="/common/js/header.js"></script>
	<script src="/common/js/common.js"></script>
</head>

<body>
	<!-- <header id="header" class="header">
		<h1>
			<a href="/" class="logo">
				<span class="blind">Test Logo</span>
			</a>
		</h1>
		<div class="gnb">
			<nav class="nav">
				<ul class="depth1" data-lenis-prevent>
					<li>
						<a href="#">Menu 1</a>
						<ul class="depth2">
							<li><a href="#">Sub Menu 1-1</a></li>
							<li><a href="#">Sub Menu 1-2</a></li>
							<li><a href="#">Sub Menu 1-3</a></li>
							<li><a href="#">Sub Menu 1-4</a></li>
							<li><a href="#">Sub Menu 1-5</a></li>
							<li><a href="#">Sub Menu 1-6</a></li>
						</ul>
					</li>
					<li>
						<a href="#">Menu 2</a>
						<ul class="depth2">
							<li><a href="#">Sub Menu 2-1</a></li>
							<li><a href="#">Sub Menu 2-2</a></li>
							<li><a href="#">Sub Menu 2-3</a></li>
							<li><a href="#">Sub Menu 2-4</a></li>
							<li><a href="#">Sub Menu 2-5</a></li>
						</ul>
					</li>
					<li>
						<a href="#">Menu 3</a>
						<ul class="depth2">
							<li><a href="#">Sub Menu 3-1</a></li>
							<li><a href="#">Sub Menu 3-2</a></li>
						</ul>
					</li>
					<li>
						<a href="#">Menu 4</a>
						<ul class="depth2">
							<li><a href="#">Sub Menu 4-1</a></li>
							<li><a href="#">Sub Menu 4-2</a></li>
						</ul>
					</li>
					<li>
						<a href="#">Menu 5</a>
					</li>
				</ul>
			</nav>
			<div class="close">
				<a href="javascript:">
					<span class="circle"></span>
					<span class="blind">Close Menu</span>
				</a>
			</div>
		</div>
		<div class="header-right">
			<div class="header-language">
				<button class="current" aria-pressed="false"><span class="text">KR</span></button>
				<ul>
					<li><a href="javascript:lang_chg('ko')">KR</a></li>
					<li><a href="javascript:lang_chg('en')">EN</a></li>
					<li><a href="javascript:lang_chg('cn')">CN</a></li>
				</ul>
			</div>
			<div class="hamburger">
				<a href="javascript:">
					<span class="bar"></span>
					<span class="bar"></span>
					<span class="bar"></span>
					<span class="blind">Open Menu</span>
				</a>
			</div>
		</div>
	</header> -->
	<main>
		<div class="intro" style="display: none;">
			<div class="bg"></div>
			<div class="intro-text">
				<div class="text-bg"></div>
				<h2 class="title">
					<p class="split">Creative Web Publisher</p>
					<p class="split">4년간의 웹 퍼블리싱 여정과 함께</p>
					<p class="split">인터랙티브한 사용자 경험을 만들어갑니다.</p>
				</h2>
			</div>
		</div>
		<section id="about" class="sec">
			<div class="bg"></div>
			<div class="inner">
				<div class="about-text">
					<p class="split">
						안녕하세요! <br>
						저는 4년차 퍼블리셔 주다운입니다.
					</p>
					<p class="split">
						CSS와 JavaScript를 활용한 동적 모션을 좋아하고 <br class="pc">
						코딩을 쉽고, 재밌게 남다르게 표현하는 걸 좋아합니다.				
					</p>
					<p class="split">
						언제나 최신동향을 따라가려 노력하며, <br class="pc">
						배운것은 나눠야 한다는 주의를 가지고 있습니다.
					</p>
					<p class="split">
						저는 제 일을 좋아하며, 좋아하니까 즐기게 되고 더 잘하고 싶어집니다.<br class="pc">
						최근에 컴포넌트 단위의 유지보수에 관심이 많아서<br class="pc">
						React, Nodejs를 공부중에 있습니다.
					</p>
				</div>
				<div class="about-img">
					<img src="/images/main/profil.jpg" alt="about">
				</div>
			</div>
		</section>
		<section id="career" class="sec">
			<div class="inner">
				<div class="career-wrap">
					<div class="career-area">
						<h3 class="career-title">커리어</h3>
						<div class="career-list">
							<article class="career-item">
								<h4 class="career-sbj">(주)서로커뮤니케이션</h4>
								<p class="career-desc">
									웹에이전시 회사로 솔루션, 그누보드, 영카트, React, Vue, Java 환경에서 퍼블리셔 구축, 유지보수 업무,
									네이버 클라우드 마크업 업무를 진행했습니다.
								</p>
								<ul class="career-tag">
									<li>2023. 03 ~ (재직중)</li>
									<li>퍼블리셔(대리)</li>
								</ul>
							</article>
							<article class="career-item">
								<h4 class="career-sbj">레이팝</h4>
								<p class="career-desc">
									이러닝 컨텐츠 사업으로 교육이러닝 개발을 주로 했습니다.
								</p>
								<ul class="career-tag">
									<li>2021. 09 ~ 2022. 11 (1년 3개월)</li>
									<li>퍼블리셔(사원)</li>
								</ul>
							</article>
						</div>
					</div>
					<div class="career-area">
						<h3 class="career-title">교육</h3>
						<div class="career-list">
							<article class="career-item">
								<h4 class="career-sbj">디코드컴퓨터학원</h4>
								<p class="career-desc">프론트엔드 웹개발자를 위한 자바스크립트,제이쿼리</p>
								<ul class="career-tag">
									<li>2021-10-30 - 2022-01-16</li>
								</ul>
							</article>
							<article class="career-item">
								<h4 class="career-sbj">디코드컴퓨터학원</h4>
								<p class="career-desc">UI/UX 웹퍼블리셔 취업과정</p>
								<ul class="career-tag">
									<li>2021-02-16 - 2021-07-07</li>
								</ul>
							</article>
						</div>
					</div>
				</div>
			</div>
		</section>
		<section id="portfolio" class="sec">
			<div class="portfolio-wrap">
				<div class="cube-container">
					<div class="cube">
						<div class="face front">
							<h3 class="heading">PROJECTS</h3>
						</div>
						<div class="face back">
							<h3 class="heading">SKILLS</h3>
						</div>
						<div class="face right">
							<canvas id="portfolio-skills"></canvas>
						</div>
						<div class="face left"></div>
						<div class="face top"></div>
						<div class="face bottom">
							<div class="noise-bg"></div>
							<canvas id="portfolio-noise"></canvas>
						</div>
					</div>
				</div>
			</div>
			<div class="" id="globe-container"></div>
		</section>
		<section id="contact" class="sec"></section>
	</main>
</body>
<script>
	window.addEventListener('DOMContentLoaded', ()=>{
		// initCircleLayout();
		gsapMotion();
	});
	const portfolioMotion = (triggerClass, isMobile) => {
		const textGlobe = new TextGlobe();
		const earth = textGlobe.getEarth();
		const section = document.querySelector(triggerClass);
		const cube = section.querySelector('.cube');
		const bg = section.querySelector('.noise-bg');
		let matterInitialized = false;
		const tl = gsap.timeline();
		const tl2 = gsap.timeline();
		gsap.set(cube, { scaleX: 0, z: '-20vw' });
		ScrollTrigger.create({
			trigger: section,
			start: 'top center',
			end: 'top 10%',
			markers: true,
			scrub: 1,
			animation: tl2
		});
		tl2.to(cube, { scaleX: 1, z: 0 });
		ScrollTrigger.create({
			trigger: section,
			start: 'top top',
			end: 'bottom bottom',
			markers: true,
			scrub: 1,
			animation: tl,
		});
		gsap.set(cube, { rotateY: -180 });
		gsap.set(bg, { autoAlpha: 0 });
		if (earth) {
        gsap.set(earth.rotation, { x: Math.PI / 2 });
    }
		tl.addLabel('motion1', "+=0");
		tl.to(cube, { rotateY: 0,
			onUpdate: function() {
				const progress = this.progress();
				if (progress >= 0.05 && !matterInitialized) {
					initMatterJS();
					matterInitialized = true;
				}
			}
		}, 'motion1')
		tl.addLabel('motion2', "+=0")
			.to(cube, { rotateX: 90 }, 'motion2')
			.addLabel('motion3', "+=0")
			.to(cube, { scale: 3.3 }, 'motion3')
			.to(bg, { autoAlpha: 1 }, 'motion3')
			.to(earth.rotation, { 
          x: Math.PI / 2 - Math.PI, // 180도 회전
          duration: 2,
          ease: "power1.inOut"
      }, 'motion3+=0.2')
		tl.addLabel('motion4', "+=0")
			.to(cube, { scale: 0}, 'motion4')

	}
	const initMatterJS = () => {
		// module aliases
		const Engine = Matter.Engine;
		const Render = Matter.Render;
		const Runner = Matter.Runner;
		const Bodies = Matter.Bodies;
		const Composite = Matter.Composite;
	
		// create an engine
		const engine = Engine.create();
	
		// 기존 렌더러 코드를 제거하고 캔버스를 사용하도록 변경
		const render = Render.create({
			canvas: document.getElementById('portfolio-skills'),
			engine: engine,
			options: {
				width: document.querySelector('.face.back').offsetWidth,
				height: document.querySelector('.face.back').offsetHeight,
				wireframes: false,
				background: 'transparent'
			}
		});
	
		// 박스 크기와 위치를 캔버스 크기에 맞게 조정
		const canvasWidth = document.querySelector('.face.back').offsetWidth;
		const canvasHeight = document.querySelector('.face.back').offsetHeight;
	
		// 스킬 아이콘 생성 함수
		const createSkillIcon = (x, y, imagePath) => {
			return Bodies.rectangle(x, y, 50, 50, { 
				render: { 
					sprite: {
						texture: imagePath,
						xScale: 0.5,
						yScale: 0.5
					}
				},
				restitution: 0.7,
				friction: 0.001,
				frictionAir: 0.01
			});
		};
		
		// 스킬 이미지 경로 배열
		const skillImages = [
			'/images/main/html.png',
			'/images/main/css.png',
			'/images/main/js.png',
			'/images/main/sass.png',
			'/images/main/xd.png',
			'/images/main/figma.png',
			'/images/main/react.png',
			'/images/main/git.png',
			'/images/main/gitlab.png',
			'/images/main/photoshop.png',
			'/images/main/illustrator.png',
			'/images/main/php.png',
		];
		
		// 랜덤 위치 생성 (겹치지 않게)
		const skills = [];
		for (let i = 0; i < 30; i++) {
				const img = skillImages[i % skillImages.length];
				const x = Math.random() * (canvasWidth - 100) + 50;
				const y = -100 - (i * 30); // 위에서부터 30px 간격으로 생성
				
				skills.push(createSkillIcon(x, y, img));
		}
		// 경계벽은 유지
		const leftWall = Bodies.rectangle(-10, canvasHeight/2, 20, canvasHeight * 2, { 
				isStatic: true,
				render: { fillStyle: 'transparent' }
		});
		const rightWall = Bodies.rectangle(canvasWidth + 10, canvasHeight/2, 20, canvasHeight * 2, { 
				isStatic: true,
				render: { fillStyle: 'transparent' }
		});		
		// 바닥 생성
		const ground = Bodies.rectangle(canvasWidth/2, canvasHeight + 10, canvasWidth, 20, { 
				isStatic: true,
				render: { fillStyle: '#333' }
		});
		
		// 모든 요소를 월드에 추가 (천장 제외)
		Composite.add(engine.world, [...skills, ground, leftWall, rightWall]);
	
		// 렌더러 실행
		Render.run(render);
	
		// 러너 생성 및 실행
		const runner = Runner.create();
		Runner.run(runner, engine);
	};
	const initCircleLayout = () => {
		const getElements = () => ({
			intro: document.querySelector('.intro'),
			sec1: document.querySelector('.sec1'),
			bg: document.querySelector('.intro .bg'),
			guideCircle: document.querySelector('.guide-circle'),
			articles: document.querySelectorAll('.guide-circle article'),
			textBoxs: document.querySelector('.intro-text'),
			textBg: document.querySelector('.intro-text .text-bg'),
			split: document.querySelectorAll('.intro-text .split'),
		});
		
		// 등장 효과 (이미지가 보이게 됨)
		const createAppearMaskEffect = (progress) => {
			const config = {
				blockCount: 30,
				staggerFactor: 1
			};

			const blockWidth = 100 / config.blockCount;
			const adjustedProgress = (progress * (config.blockCount / config.staggerFactor)) / (config.blockCount / (config.staggerFactor + 1));

			const maskPatterns = Array.from({ length: config.blockCount }, (_, index) => {
				const blockStart = (index * blockWidth).toFixed(5);
				const blockEnd = ((index + 1) * blockWidth).toFixed(5);

				const appearanceThreshold = (config.blockCount - index - 1) / config.blockCount;
				const blockProgress = Math.max(0, Math.min(1,
					(adjustedProgress - appearanceThreshold) * config.staggerFactor
				));

				const blackEndPosition = (parseFloat(blockStart) + blockProgress * blockWidth).toFixed(5);
				const finalBlackEnd = Math.min(parseFloat(blackEndPosition), parseFloat(blockEnd)).toFixed(5);

				return `black ${blockStart}%, black ${finalBlackEnd}%, transparent ${finalBlackEnd}%, transparent ${blockEnd}%`;
			});

			return maskPatterns.join(', ');
		};
		// 퇴장 효과 (이미지가 사라짐)
		const createDisappearMaskEffect = (progress, direction = 'ltr') => { // 'ltr' (left to right) 또는 'rtl' (right to left)
			const config = {
				blockCount: 30,
				staggerFactor: 2
			};

			const blockWidth = 100 / config.blockCount;
			const adjustedProgress = (progress * (config.blockCount / config.staggerFactor)) / (config.blockCount / (config.staggerFactor + 1));

			const maskPatterns = Array.from({ length: config.blockCount }, (_, index) => {
				const blockStart = (index * blockWidth).toFixed(5);
				const blockEnd = ((index + 1) * blockWidth).toFixed(5);

				// direction에 따라 다른 방향으로 처리
				const appearanceThreshold = direction === 'ltr'
					? index / config.blockCount
					: (config.blockCount - 1 - index) / config.blockCount;

				const blockProgress = Math.max(0, Math.min(1,
					(adjustedProgress - appearanceThreshold) * config.staggerFactor
				));

				if (direction === 'ltr') {
					// 왼쪽에서 오른쪽으로
					const transparentEndPosition = (parseFloat(blockStart) + blockProgress * blockWidth).toFixed(5);
					const finalTransparentEnd = Math.min(parseFloat(transparentEndPosition), parseFloat(blockEnd)).toFixed(5);
					return `transparent ${blockStart}%, transparent ${finalTransparentEnd}%, black ${finalTransparentEnd}%, black ${blockEnd}%`;
				} else {
					// 오른쪽에서 왼쪽으로
					const transparentStartPosition = (parseFloat(blockEnd) - blockProgress * blockWidth).toFixed(5);
					const finalTransparentStart = Math.max(parseFloat(transparentStartPosition), parseFloat(blockStart)).toFixed(5);
					return `black ${blockStart}%, black ${finalTransparentStart}%, transparent ${finalTransparentStart}%, transparent ${blockEnd}%`;
				}
			});

			return maskPatterns.join(', ');
		};

		const runMaskAnimation = (element, maskType, direction = 'ltr') => {
			return new Promise((resolve, reject) => {
				const { intro, bg, textBoxs, guideCircle, articles, split, sec1 } = getElements();
				// gsap.set(element, { autoAlpha: 0 });
	
				gsap.to({}, {
					duration: 1.5,
					onUpdate: function () {
						const progress = this.progress();
						const maskPattern = maskType(progress, direction);
						element.style.setProperty('--mask-section', maskPattern);
					},
					onComplete: () => {
						document.body.style.overflow = 'visible';
						lenis.start();
						resolve();
					}
				});
	
				gsap.to(element, {
					autoAlpha: 1,
					duration: 0.1
				});
			});
		};

		function initScrollAnimation() {
			const { intro, bg, guideCircle, articles, textBoxs, split, sec1, textBg } = getElements();
			const tl = gsap.timeline();
			split.forEach(item => {
				gsap.set(item.querySelectorAll('.word'), { autoAlpha: 0, y: 0 });
			});
			gsap.set(textBg, { scale: 1.4, rotate: 10 });
			const totalDuration = 8;
			const segmentDuration = totalDuration / 3;
			const staggerTime = 0.05;

			document.body.style.overflow = 'hidden';
			lenis.stop();
			
			tl.to(split[0].querySelectorAll('.word'), { autoAlpha: 1, y: 0, ease: 'power2.inOut', stagger: staggerTime }, 'intro')
				.to(textBg, { scale: 1, rotate: 0, duration: totalDuration }, 'intro')
				.to(split[0].querySelectorAll('.word'), { autoAlpha: 0, y: 0, ease: 'power2.inOut', stagger: staggerTime }, 'intro+=' + (segmentDuration - 1))
				.to(split[1].querySelectorAll('.word'), { autoAlpha: 1, y: 0, ease: 'power2.inOut', stagger: staggerTime }, 'intro+=' + segmentDuration)
				.to(split[1].querySelectorAll('.word'), { autoAlpha: 0, y: 0, ease: 'power2.inOut', stagger: staggerTime }, 'intro+=' + (segmentDuration * 2 - 1))
				.to(split[2].querySelectorAll('.word'), {
					autoAlpha: 1, y: 0, ease: 'power2.inOut', stagger: staggerTime, onComplete: async () => {
						await runMaskAnimation(textBoxs, createDisappearMaskEffect, 'ltr');
						gsap.delayedCall(0.5, async () => { 
							await runMaskAnimation(intro, createDisappearMaskEffect, 'rtl');
							// intro.remove();
						});
					}
				}, 'intro+=' + (segmentDuration * 2))
		}

		function reset() {
			ScrollTrigger.getAll().forEach(st => st.kill());
			initScrollAnimation();
		}

		// positionArticles();
		initScrollAnimation();
		window.addEventListener('resize', reset);
	}
	const gsapMotion = () => {
		let mm = gsap.matchMedia();
	
		mm.add({
			isMobile: "(max-width: 767px)",
			isDesktop: "(min-width: 768px)"
		}, (context) => {
			let { isMobile, isDesktop } = context.conditions;
	
			portfolioMotion('#portfolio', isMobile);
		});
	}

	class TextGlobe {
      constructor(options = {}) {
        // 기본 옵션 설정
        this.options = {
          container: '#globe-container',
          globeRadius: 1.57,
          textItems: [
            "금성아트", "아이옴진", "아트앤컬쳐", "김종훈", "픽셀플러스", 
            "코드플로", "플랜티넷", "두산밥캣코리아", "케이엔제이", "현대파이프", 
            "니즈", "HLB", "리치디바인파트너", "리치디바인컨설팅", "인터엑스", 
            "키움인베스트먼트",
          ],
          ...options
        };
        
        // Three.js 변수 초기화
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.earth = null;
        
        // 초기화 실행
        this.init();
      }
      
      init() {
        // Scene 설정
        this.scene = new THREE.Scene();
        
        // Camera 설정
        this.camera = new THREE.PerspectiveCamera(
          80, 
          window.innerWidth / window.innerHeight,
          0.1, 
          1000
        );
        this.camera.position.z = 2.4;
        
        // Renderer 설정
        this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setClearColor(0x000000, 0);
        this.renderer.domElement.style.position = 'absolute';
        this.renderer.domElement.style.top = '0';
        this.renderer.domElement.style.left = '0';
        this.renderer.domElement.style.width = '100%';
        this.renderer.domElement.style.height = '100%';
        this.renderer.domElement.style.zIndex = '1';
        
        document.querySelector(this.options.container).appendChild(this.renderer.domElement);
        
        // 조명 설정
        this.scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const pointLight = new THREE.PointLight(0xffffff, 1);
        pointLight.position.set(5, 3, 5);
        this.scene.add(pointLight);
        
        // 지구본 생성
        this.createGlobe();
        
        // 텍스트 추가
        this.addTextToGlobe();
        
				this.getEarth = () => this.earth;
        
        // 애니메이션 시작 및 이벤트 리스너 등록
        this.animate();
        window.addEventListener('resize', this.onWindowResize.bind(this));
      }
      
      // 지구본 생성 메서드
      createGlobe() {
        const earthGeometry = new THREE.SphereGeometry(this.options.globeRadius, 64, 64);
        const earthMaterial = new THREE.MeshBasicMaterial({
          color: 0x000000,
          transparent: true,
          opacity: 0, // 완전 투명
          wireframe: false
        });
        
        this.earth = new THREE.Mesh(earthGeometry, earthMaterial);
        this.earth.rotation.x = Math.PI / 2; // 텍스트가 하단에 위치하도록 초기 회전
        this.scene.add(this.earth);
      }
      
      // 3D 텍스트 추가 함수
      addTextToGlobe() {
        this.options.textItems.forEach((text, index) => {
          // 텍스트 위치 계산
          const angle = (index / (this.options.textItems.length - 1)) * Math.PI * 0.5 + Math.PI * 0.25;
          
          // 텍스트를 캔버스에 그리기
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          const fontSize = 100; // 폰트 해상도
          const fontFamily = 'Arial, 맑은 고딕, sans-serif';
          
          // 텍스트 크기 측정을 위한 폰트 설정
          ctx.font = `bold ${fontSize}px ${fontFamily}`;
          const textMetrics = ctx.measureText(text);
          
          // 텍스트 크기에 맞게 캔버스 크기 조정 (패딩 포함)
          const padding = 24;
          const textWidth = textMetrics.width + padding * 2;
          const textHeight = fontSize * 1.5;
          
          canvas.width = textWidth;
          canvas.height = textHeight;
          
          // 다시 폰트 설정 (캔버스 리사이즈 후 컨텍스트 리셋됨)
          ctx.fillStyle = '#ffffff';
          ctx.font = `bold ${fontSize}px ${fontFamily}`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(text, canvas.width / 2, canvas.height / 2);
          
          // 텍스처 생성
          const texture = new THREE.CanvasTexture(canvas);
          texture.needsUpdate = true;
          
          // 종횡비 계산
          const aspectRatio = textWidth / textHeight;
          
          // 기준 높이 (모든 텍스트 높이는 동일하게 유지)
          const baseHeight = 0.125;
          const baseWidth = baseHeight * aspectRatio;
          
          // 텍스트 메시 생성 - 텍스트 길이에 맞게 너비 조정
          const planeGeometry = new THREE.PlaneGeometry(baseWidth, baseHeight);
          const planeMaterial = new THREE.MeshBasicMaterial({
            map: texture,
            transparent: true,
            // depthTest: false, // 깊이 테스트 비활성화로 항상 보이게 함
            depthWrite: false,
            side: THREE.DoubleSide
          });
          
          const textMesh = new THREE.Mesh(planeGeometry, planeMaterial);
          textMesh.renderOrder = 10000; // 높은 렌더 순서
          
          // 텍스트 위치 계산 및 설정
          const y = Math.cos(angle) * 1.4;
          const radius = this.options.globeRadius;
          const xzRadius = Math.sqrt(radius * radius - y * y);
          const z = xzRadius + 0.05; // 약간 앞으로 이동
          
          textMesh.position.set(0, y, z);
          textMesh.lookAt(0, 0, 0);
          textMesh.rotateY(Math.PI);
          textMesh.rotateX(-Math.PI * 0.02);
          
          this.earth.add(textMesh);
        });
      }
      
      // 애니메이션 함수
      animate = () => {
        requestAnimationFrame(this.animate);
        this.renderer.render(this.scene, this.camera);
      }
      
      // 창 크기 변경 대응
      onWindowResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        
        // 화면 비율에 따라 카메라 위치 조정
        const aspect = window.innerWidth / window.innerHeight;
        this.camera.position.z = aspect < 1 ? 2.8 : 2.4;
      }
    }
    
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="common/js/noise.js"></script>
</html>